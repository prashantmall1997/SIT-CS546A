const express = require("express");
const router = express.Router();
const data = require("../data");
const reviewFunction = data.reviews;
const bookFunction = data.books;
var ObjectID = require("mongodb").ObjectID;

async function idFormatChecker(id) {
  if (id === undefined) {
    throw {
      status: 400,
      error: "ID parameter not passed - Generated by '/routes/reviews.js'.",
    };
  }

  if (typeof id != "string") {
    throw {
      status: 400,
      error:
        "ID paramenter must be passed in string format from URL - Generated by '/routes/reviews.js'.",
    };
  }

  if (!ObjectID.isValid(id)) {
    throw {
      status: 400,
      error:
        "ID paramenter passed in string format from URL is not a valid ObjectID - Generated by '/routes/reviews.js'.",
    };
  }
}

async function reviewFormatChecker(review, allFieldsMandatory = 0) {
  if (allFieldsMandatory === 1) {
    if (
      !review.title ||
      !review.reviewer ||
      !review.rating ||
      !review.dateOfReview ||
      !review.review
    ) {
      throw {
        status: 400,
        error:
          "Must provide all fields: Title, Reviewer, Rating, Date when review published, Review - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (allFieldsMandatory === 0) {
    if (
      !review.title &&
      !review.reviewer &&
      !review.rating &&
      !review.dateOfReview &&
      !review.review
    ) {
      throw {
        status: 400,
        error:
          "Must provide atleast one field: Title, Reviewer, Rating, Date when review published, Review - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (review.title) {
    if (typeof review.title != "string") {
      throw {
        status: 400,
        error:
          "Review title must be provided in string format - Generated by '/routes/reviews.js'.",
      };
    }
    if (review.title.trim() === "") {
      throw {
        status: 400,
        error:
          "Review title cannot be empty string or just blank spaces - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (review.reviewer) {
    if (typeof review.reviewer != "string") {
      throw {
        status: 400,
        error:
          "Reviewer name/username must be provided in string format - Generated by '/routes/reviews.js'.",
      };
    }
    if (review.reviewer.trim() === "") {
      throw {
        status: 400,
        error:
          "Reviewer name/username cannot be empty string or just blank spaces - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (review.rating) {
    if (typeof review.rating != "number") {
      throw {
        status: 400,
        error:
          "Rating must be provided in number format - Generated by '/routes/reviews.js'.",
      };
    }
    if (review.rating < 1 || review.rating > 5) {
      throw {
        status: 400,
        error:
          "Rating must be a range from 1 to 5 - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (review.dateOfReview) {
    if (
      typeof review.dateOfReview != "string" ||
      isNaN(Date.parse(review.dateOfReview)) ||
      new Date(Date.parse(review.dateOfReview)).getDate() !=
        review.dateOfReview.split("/")[1]
    ) {
      throw {
        status: 400,
        error:
          "Review date is not a valid date - Generated by '/routes/reviews.js'.",
      };
    }

    var regEx = /^[0-9]{1,2}?[/][0-9]{1,2}?[/][0-9]{4}?$/;

    if (!review.dateOfReview.match(regEx)) {
      throw {
        status: 400,
        error:
          "Review date is not in correct format of MM/DD/YYYY - Generated by '/routes/reviews.js'.",
      };
    }
  }

  if (review.review) {
    if (typeof review.review != "string") {
      throw {
        status: 400,
        error:
          "Review must be provided in string format - Generated by '/routes/reviews.js'.",
      };
    }
    if (review.review.trim() === "") {
      throw {
        status: 400,
        error:
          "Review cannot be empty string or just blank spaces - Generated by '/routes/reviews.js'.",
      };
    }
  }
}

router.get("/:id", async (req, res) => {
  try {
    await idFormatChecker(req.params.id);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
    return;
  }

  try {
    const book = await bookFunction.getBookById(req.params.id);
    if (!book) {
      throw {
        status: 404,
        error: `No book found with ID '${id}' - Generated by '/routes/reviews.js'. `,
      };
    }

    const review = await reviewFunction.getReviews(req.params.id);
    res.status(200).json(review);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
  }
});

router.post("/:id", async (req, res) => {
  try {
    await idFormatChecker(req.params.id);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
    return;
  }

  const reviewData = req.body;

  try {
    await reviewFormatChecker(reviewData, 1);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
    return;
  }

  try {
    const book = await bookFunction.getBookById(req.params.id);
    if (!book) {
      throw {
        status: 404,
        error: `No book found with ID '${id}' - Generated by '/routes/reviews.js'. `,
      };
    }

    const newReview = await reviewFunction.addReview(req.params.id, reviewData);
    res.status(200).json(newReview);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
  }
});

router.get("/review/:id", async (req, res) => {
  try {
    await idFormatChecker(req.params.id);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
    return;
  }

  try {
    const review = await reviewFunction.getReview(req.params.id);
    res.status(200).json(review);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
  }
});

router.delete("/:id", async (req, res) => {
  try {
    await idFormatChecker(req.params.id);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
    return;
  }

  try {
    const deletedReview = await reviewFunction.deleteReview(req.params.id);
    res.status(200).json(deletedReview);
  } catch (e) {
    res.status(e.status).json({ error: e.error });
  }
});

module.exports = router;
