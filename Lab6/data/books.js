const mongoCollections = require("../config/mongoCollections");
const books = mongoCollections.books;
var ObjectID = require("mongodb").ObjectID;

async function idFormatChecker(id) {
  if (id === undefined) {
    throw {
      status: 400,
      error: "ID parameter not passed - Generated by '/data/books.js'.",
    };
  }

  if (typeof id != "string") {
    throw {
      status: 400,
      error:
        "ID paramenter must be passed in string format from URL - Generated by '/data/books.js'.",
    };
  }

  if (!ObjectID.isValid(id)) {
    throw {
      status: 400,
      error:
        "ID paramenter passed in string format from URL is not a valid ObjectID - Generated by '/data/books.js'.",
    };
  }
}

async function bookFormatChecker(book, allFieldsMandatory = 0) {
  if (allFieldsMandatory === 1) {
    if (
      !book.title ||
      !book.author ||
      !book.genre ||
      !book.datePublished ||
      !book.summary
    ) {
      throw {
        status: 400,
        error:
          "Must provide all fields: Title, Author, Genre, Date Published, Summary - Generated by '/data/books.js'.",
      };
    }
  }

  if (allFieldsMandatory === 0) {
    if (
      !book.title &&
      !book.author &&
      !book.genre &&
      !book.datePublished &&
      !book.summary
    ) {
      throw {
        status: 400,
        error:
          "Must provide atleast one field: Title, Author, Genre, Date Published, Summary - Generated by '/data/books.js'.",
      };
    }
  }

  if (book.title) {
    if (typeof book.title != "string") {
      throw {
        status: 400,
        error:
          "Book title must be provided in string format - Generated by '/data/books.js'.",
      };
    }
    if (book.title.trim() === "") {
      throw {
        status: 400,
        error:
          "Book title cannot be empty string or just blank spaces - Generated by '/data/books.js'.",
      };
    }
  }

  if (book.author) {
    if (
      !book.author.authorFirstName ||
      !book.author.authorLastName ||
      typeof book.author.authorFirstName != "string" ||
      typeof book.author.authorLastName != "string" ||
      book.author.authorFirstName.trim() === "" ||
      book.author.authorLastName.trim() === ""
    ) {
      throw {
        status: 400,
        error:
          "Book Author First and Last name must be provided in non empty string format - Generated by '/data/books.js'.",
      };
    }
  }

  if (book.genre) {
    if (!Array.isArray(book.genre) || book.genre.length < 1) {
      throw {
        status: 400,
        error:
          "Book genre must be provided in non empty array format - Generated by '/data/books.js'.",
      };
    }

    for (var count = 0; count < book.genre.length; count++) {
      if (
        typeof book.genre[count] != "string" ||
        book.genre[count].trim() === ""
      ) {
        throw {
          status: 400,
          error:
            "All book genre array elements must be of non empty string format - Generated by '/data/books.js'.",
        };
      }
    }
  }

  if (book.datePublished) {
    // new Date(Date.parse(book.datePublished)).getDate() !=
    //   book.datePublished.split("/")[1];

    if (
      typeof book.datePublished != "string" ||
      isNaN(Date.parse(book.datePublished)) ||
      new Date(Date.parse(book.datePublished)).getDate() !=
        book.datePublished.split("/")[1]
    ) {
      throw {
        status: 400,
        error:
          "Published date parameter is not a valid date string - Generated by '/data/books.js'.",
      };
    }

    var regEx = /^[0-9]{1,2}?[/][0-9]{1,2}?[/][0-9]{4}?$/;

    if (!book.datePublished.match(regEx)) {
      throw {
        status: 400,
        error:
          "Published date is not in correct format of MM/DD/YYYY - Generated by '/data/books.js'.",
      };
    }
  }

  if (book.summary) {
    if (typeof book.summary != "string") {
      throw {
        status: 400,
        error:
          "Summary must be provided in string format - Generated by '/data/books.js'.",
      };
    }
    if (book.summary.trim() === "") {
      throw {
        status: 400,
        error:
          "Summary cannot be empty string or just blank spaces - Generated by '/data/books.js'.",
      };
    }
  }
}

const exportedMethods = {
  async getAllBooks() {
    const bookCollection = await books();
    return (
      await bookCollection
        .find({}, { projection: { _id: 1, title: 1 } })
        .toArray()
    ).map(function (book) {
      return { _id: book._id.toString(), title: book.title };
    });
  },

  async addBook(bookData) {
    try {
      await bookFormatChecker(bookData, 1);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const bookCollection = await books();

      bookData.reviews = [];

      const newInsertInformation = await bookCollection.insertOne(bookData);
      if (newInsertInformation.insertedCount === 0)
        throw {
          status: 500,
          error: "Failed to add Book to DB - Generated by '/data/books.js'.",
        };

      const insertedBook = await this.getBookById(
        newInsertInformation.insertedId.toString()
      );
      insertedBook._id = insertedBook._id.toString();

      return insertedBook;
    } catch (e) {
      throw { status: e.status, error: e.error };
    }
  },

  async getBookById(id) {
    try {
      await idFormatChecker(id);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const bookCollection = await books();

      const book = await bookCollection.findOne({ _id: ObjectID(id) });
      if (!book) {
        throw {
          status: 404,
          error: `No book found with ID '${id}' - Generated by '/data/books.js'. `,
        };
      }

      book._id = book._id.toString();
      book.reviews.forEach((review) => (review._id = review._id.toString()));
      return book;
    } catch (e) {
      throw { status: e.status, error: e.error };
    }
  },

  async updateBook(id, bookData) {
    try {
      await idFormatChecker(id);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      await bookFormatChecker(bookData, 1);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const bookCollection = await books();

      const bookToUpdate = await this.getBookById(id);
      if (!bookToUpdate) {
        throw {
          status: 404,
          error: `No book found with ID '${id}' - Generated by '/data/books.js'. `,
        };
      }

      bookData.reviews = bookToUpdate.reviews;
      bookData.reviews.forEach((review) => (review._id = ObjectID(review._id)));
      delete bookToUpdate._id;

      if (JSON.stringify(bookToUpdate) === JSON.stringify(bookData)) {
        throw {
          status: 400,
          error: `Book found with ID '${id}' has not been updated as no new values has been provided - Generated by '/data/books.js'. `,
        };
      }

      const updateBook = await bookCollection.updateOne(
        { _id: ObjectID(id) },
        { $set: bookData }
      );
      if (updateBook.result.nModified === 0) {
        throw {
          status: 500,
          error: `Book found with ID '${id}' has not been updated - Generated by '/data/books.js'. `,
        };
      }

      const updatedBook = await this.getBookById(id);
      return updatedBook;
    } catch (e) {
      throw { status: e.status, error: e.error };
    }
  },

  async patchBook(id, bookData) {
    try {
      await idFormatChecker(id);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      await bookFormatChecker(bookData, 0);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const bookCollection = await books();

      const bookToUpdate = await this.getBookById(id);
      if (!bookToUpdate) {
        throw {
          status: 404,
          error: `No book found with ID '${id}' - Generated by '/data/books.js'. `,
        };
      }

      const newBook = {};

      if (bookData.title && bookData.title != bookToUpdate.title) {
        newBook.title = bookData.title;
      }
      if (
        bookData.author &&
        JSON.stringify(bookData.author) != JSON.stringify(bookToUpdate.author)
      ) {
        newBook.author = bookData.author;
      }

      function arrayEquals(a, b) {
        return (
          Array.isArray(a) &&
          Array.isArray(b) &&
          a.length === b.length &&
          a.every((val, index) => val === b[index])
        );
      }

      if (bookData.genre) {
        const union = [...new Set([...bookData.genre, ...bookToUpdate.genre])];
        if (!arrayEquals(union, bookToUpdate.genre)) {
          newBook.genre = union;
        }
      }

      if (
        bookData.datePublished &&
        bookData.datePublished != bookToUpdate.datePublished
      ) {
        newBook.datePublished = bookData.datePublished;
      }
      if (bookData.summary && bookData.summary != bookToUpdate.summary) {
        newBook.summary = bookData.summary;
      }

      if (JSON.stringify(newBook) === "{}") {
        throw {
          status: 400,
          error: `Book found with ID '${id}' has not been updated as no new values has been provided - Generated by '/data/books.js'. `,
        };
      }

      const updatedBook = await bookCollection.updateOne(
        { _id: ObjectID(id) },
        { $set: newBook }
      );

      if (updatedBook.result.nModified === 0) {
        throw {
          status: 500,
          error: `Book found with ID '${id}' has not been updated - Generated by '/data/books.js'. `,
        };
      }

      return await this.getBookById(id);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }
  },

  async removeBook(id) {
    try {
      await idFormatChecker(id);
    } catch (e) {
      throw { status: e.status, error: e.error };
    }

    try {
      const bookCollection = await books();

      const book = await this.getBookById(id);
      if (!book) {
        throw {
          status: 404,
          error: `No book found with ID '${id}' - Generated by '/data/books.js'. `,
        };
      }

      const deletionInfo = await bookCollection.removeOne({
        _id: ObjectID(id),
      });

      if (deletionInfo.deletedCount === 0) {
        throw {
          status: 500,
          error: `Book found with ID '${id}' failed to be deleted - Generated by '/data/books.js'. `,
        };
      }

      return { bookId: book._id.toString(), deleted: true };
    } catch (e) {
      throw { status: e.status, error: e.error };
    }
  },
};

module.exports = exportedMethods;
